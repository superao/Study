// 引用的学习
// 1.引用做函数的返回值
// 2.对比学习指针作为返回值,值作为返回值,引用作为返回值

#include <iostream>

using namespace std;

// 引用作为返回值
int& Add(int a, int b) {

  int sum = a + b;
  return sum;
}

// 值作为返回值
int Add1(int a, int b) {

  int sum = a + b;
  return sum;
}

// 指针作为返回值
int* Add2(int a, int b) {

  int sum = a + b;
  return &sum;
}
int main() {

  int& ret = Add(10,20);
  Add(1,2);
  cout << "hello world!" << endl;
  cout << "ret = " << ret << endl;


  cout << "================" << endl;


  int* ptr = Add2(12,21);
  Add2(1,6);
  cout << "hello world!" << endl;
  cout << "*ptr = " << *ptr << endl;


  cout << "================" << endl;


  int temp = Add1(20,20);
  Add1(10,10);
  cout << "temp = " << temp << endl;

  return 0;
}

// 经过以上的实验,得出以下的结论:
// 1.三个函数使用的都是临时变量来返回,临时变量的作用域为自身的函数.
// 2.当函数调用完成后,操作系统就会释放那块区域,供其他东西使用,所以,
// 当你访问那块区域时,它的值是不确定的,有可能已经被覆盖,有可能没有,
// 所以才看到有的时候,有时候它的值是正确的,有时候它的值不是正确的。
// 效率的比较:
// 传值作为返回值,函数的参数:它们不会直接返回,而是先申请一块区域,将值拷贝进去,然后再返回,返回变量的一份临时拷贝
// 引用:它不会进行拷贝,而是直接对原来的区域起了个别名,以供自己使用,所以,效率大大提高
//
// 因此,以后再使用引用作为返回值,为了避免出错,返回的必须为全局变量
//
// 引用从语法角度上来说,它是没有空间的,和其他变量共用一块内存,
// 从底层实现角度来说,它是有空间的,利用指针来实现的.

